# N2S Requirements Document

## Overview
N2S is a storage coordination service that synchronizes a source filesystem to a destination blob store. Each source-destination pair operates independently with its own metadata and state tracking.

## Core Concepts

### Source
- Real filesystem with directory structure, file metadata, permissions
- Contains the authoritative state of what data exists
- Maintains in-memory tracking of upload status
- Drives all synchronization operations

### Destination
- Content-addressed blob storage containing encrypted file content
- Stores metadata files describing filesystem state and change history
- Passive storage - does not compute or modify state
- Self-describing through stored manifests and changesets

### Changeset
A record describing the transition from one filesystem state to another, containing:
- `changeset_id`: hash(end_manifest_hash + previous_changeset_id)
- `previous_changeset_id`: ID of preceding changeset (forms verification chain)
- `timestamp`: when changeset was created
- `source_id`: identifier of source that created this changeset
- `start_manifest_hash`: hash of filesystem state before changes
- `end_manifest_hash`: hash of filesystem state after changes
- `blob_count`: number of blobs referenced in actions
- `note`: optional human-readable description
- `actions`: list of (blob_id, action, path, mtime, size) tuples where action is WRITE or REMOVE

### Manifest
Complete snapshot of filesystem state containing:
- `changeset_id`: ID of changeset that produced this manifest
- `timestamp`: when manifest was created
- `file_list`: mapping of path â†’ {blob_id, size, mtime} for all files

### Checkpoint
A manifest stored at configurable intervals (every Nth changeset) to enable efficient recovery without replaying entire changeset history.

## Destination Structure
```
destination/
  blob-store/
    <blob_id>...           # blob content per existing n2s specification
  changesets/
    <changeset_id>.json    # changeset records
    <changeset_id>.manifest.json  # checkpoints (every N changesets)
  current-manifest.json    # latest filesystem state
  source.yaml             # source metadata and configuration
  .lock                   # process coordination
```

## Source Operations

### Synchronization Process
1. **Acquire lock** at destination
2. **Retrieve current manifest** from destination
3. **Compare filesystems**: source filesystem vs destination manifest
4. **Compute changeset**: identify files to add/remove/modify
5. **Upload blobs**: send new/changed file content to blob store
6. **Verify blob upload**: confirm all referenced blobs exist at destination
7. **Upload changeset**: write changeset record to destination
8. **Update current manifest**: write new manifest reflecting end state
9. **Create checkpoint**: if configured interval reached, store manifest as checkpoint
10. **Release lock**

### Changeset Computation
- Compare source filesystem state against destination manifest
- Generate actions for each difference:
  - New files: (blob_id, WRITE, path, mtime, size)
  - Modified files: (blob_id, WRITE, path, mtime, size)
  - Deleted files: (null, REMOVE, path, old_mtime, old_size)
- Compute start_manifest_hash from current destination manifest
- Compute end_manifest_hash from projected filesystem state
- Generate changeset_id from end_manifest_hash + previous_changeset_id

### Blob Management
- Blob creation follows existing n2s specification
- Before uploading, check if blob already exists at destination
- Track upload status in source memory
- Only proceed to changeset upload when all blobs confirmed present
- Orphaned blobs (uploaded but not referenced by any changeset) are acceptable

## Recovery and Verification

### Current State Recovery
1. Read current-manifest.json to get latest changeset_id
2. Check if corresponding checkpoint exists
3. If checkpoint exists: use as starting point
4. If no checkpoint: follow previous_changeset_id chain to find latest checkpoint
5. Apply changesets forward from checkpoint to reconstruct current state

### Chain Verification
- Each changeset cryptographically references its predecessor
- Broken chains indicate missing or corrupted changesets
- Recovery falls back to latest valid checkpoint

### Bootstrap Process
- Initial synchronization creates genesis changeset with no predecessor
- First manifest represents complete source filesystem state
- Subsequent changesets build on this foundation

## Configuration

### Source Configuration (n2s.yml)
- Destination directory name
- Checkpoint frequency (every N changesets)
- Source identification metadata
- Storage backend settings

### Process Coordination
- Single process lock per source-destination pair
- Lock held for entire synchronization operation
- Lock cleanup handled by source process
- Long-held locks acceptable due to 1:1 pairing

## Data Integrity
- All content hashed per existing n2s specification
- Changeset chaining provides tamper detection
- Manifest hashes verify filesystem state consistency
- Multiple recovery paths (full replay vs checkpoint + incremental)
- Optional encryption handled per existing n2s blob specification
